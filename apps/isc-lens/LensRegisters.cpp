//-----------------------------------------------------------------------------------------------------------------
// The LensRegisters are defined in the Whisper Host Interface beginning on page 39.
// Initial revision is 11/13/2018.
//
// Please update revisions as appropriate.
//
//  The contents of LensRegisters reflect the memory in the lens.  Changes generated by the 
//  DownloadSettings iNet API must be made through the Lens::WriteRegister function.  At which
//  point the LenRegister needs to be reloaded.
//
#include <string>
#include <boost/format.hpp>
#include "LensRegisters.h"
#include "colordef.h"

//-----------------------------------------------------------------------------------------------------------------
LensRegisters::LensRegisters(): m_Initialize(0xff)
{
}

//-----------------------------------------------------------------------------------------------------------------
// SetData - copy the buffer pulled from the spi line into the registers for decomposition
void LensRegisters::SetData(unsigned char *buf)
{
	int i = 0;
	
	m_Initialize = buf[i]; i++;
	memcpy(m_MAC, &buf[i], 8); i+= 8;
	m_RadioHardwareVersion = buf[i]; i++;
	memcpy(m_RadioOSVersion, &buf[i], 3); i+= 3;
	memcpy(m_RadioProtocolVersion, &buf[i], 3); i+= 3;
	memcpy(m_NetworkID, &buf[i], 2); i+= 2;
	m_EncryptionType = buf[i]; i++;
	memcpy(m_EncryptionKey, &buf[i], 16); i+= 16;
	m_PrimaryPublicChannel = buf[i]; i++;
	m_SecondaryPublicChannel = buf[i]; i++;
	memcpy(m_ActiveChannelMask, &buf[i], 2); i+= 2;
	m_NetworkStatus = buf[i]; i++;
	m_MaxNumberOfHops = buf[i]; i++;
	m_LeaderQualificationScore = buf[i]; i++;
	m_NetworkInterval = buf[i]; i++;
	m_NumberOfPeers = buf[i]; i++;
	m_MaxNumberOfPeers = buf[i]; i++;
	memcpy(m_FeatureBits, &buf[i], 2); i+= 2;
	memcpy(m_ScriptCRC, &buf[i], 2); i+= 2;
	m_TransmitPowerSetting = buf[i]; i++;
	memcpy(m_GatewayChannelMask, &buf[i], 2); i+= 2;
	m_CurrentListeningChannel = buf[i]; i++;
	m_INetConnectionFlag = buf[i]; i++;
}

//-----------------------------------------------------------------------------------------------------------------
// Dump - Write the entire set of registers as human readable translated vaules.
//  buf (output) - string to load with the output.
//  returns: output so that strings can be changed.
std::string LensRegisters::toStr(std::string &buf)  // output the whole register block as readable text.
{
	std::string data;
	buf.empty();
	buf = Initialize(data);	buf += "\n";
	buf += MAC(data);	buf += "\n";
	buf += RadioHardwareVersion(data);	buf += "\n";
	buf += RadioOSVersion(data);	buf += "\n";
	buf += RadioProtocolVersion(data);	buf += "\n";
	buf += NetworkID(data);	buf += "\n";
	buf += EncryptionType(data);	buf += "\n";
	buf += EncryptionKey(data);	buf += "\n";
	buf += PrimaryPublicChannel(data);	buf += "\n";
	buf += SecondaryPublicChannel(data);	buf += "\n";
	buf += ActiveChannelMask(data);	buf += "\n";
	buf += NetworkStatus(data);	buf += "\n";
	buf += MaxNumberOfHops(data);	buf += "\n";
	buf += LeaderQualificationScore(data);	buf += "\n";
	buf += NetworkInterval(data);	buf += "\n";
	buf += NumberOfPeers(data);	buf += "\n";
	buf += MaxNumberOfPeers(data);	buf += "\n";
	buf += FeatureBits(data);	buf += "\n";
	buf += ScriptCRC(data);	buf += "\n";
	buf += TransmitPowerSetting(data);	buf += "\n";
	buf += GatewayChannelMask(data);	buf += "\n";
	buf += CurrentListeningChannel(data);	buf += "\n";
	buf += INetConnectionFlag(data);	buf += "\n";
	return buf;
}

// FORMATTERS:  The following functions create a human readable format with meaning for the various registers.
//  They all take an incoming string that is filled.  That string is then returned.
//  There is NO end of line characters added to the output.
//
//-----------------------------------------------------------------------------------------------------------------
std::string LensRegisters::Initialize(std::string &output)
{
	if ((int)Initialize() == 0xA5)
		output = GREEN_ON "Registers have been initialized by the radio." RESET_COLOR;
	else
		output = str(	boost::format(RED_ON "Uninitialized : value is 0x%02x" RESET_COLOR ) % ((int)Initialize()) );

	return output;
}


//-----------------------------------------------------------------------------------------------------------------
std::string LensRegisters::MAC(std::string &output)
{
	output = str( boost::format("MAC: " GREEN_ON  "%02x") % (int)m_MAC[0]);
	
	for (short i = 1; i < 8; i++)
		output += str( boost::format(":%02x") % (int)m_MAC[i]);	

	output += RESET_COLOR;
	return output;
}


//-----------------------------------------------------------------------------------------------------------------
std::string LensRegisters::LensRegisters::RadioHardwareVersion(std::string &output)
{
	output = str( boost::format("Radio Hardware Version: " GREEN_ON "%d" RESET_COLOR) % (int)m_RadioHardwareVersion);
	return output;
}

std::string LensRegisters::RadioOSVersion(std::string &output)
{
	output = str( boost::format("Radio OS Version:  " GREEN_ON "%d.%d.%d" RESET_COLOR) % (int)m_RadioOSVersion[0] % (int)m_RadioOSVersion[1] % (int)m_RadioOSVersion[2]);
	return output;
}


std::string LensRegisters::RadioProtocolVersion(std::string &output)
{
	output = str( boost::format("Radio Protocol Version:  " GREEN_ON "%d-%d-%d" RESET_COLOR) % (int)m_RadioProtocolVersion[0] % (int)m_RadioProtocolVersion[1] % (int)m_RadioProtocolVersion[2]);
	return output;
}
std::string LensRegisters::rawRadioProtocolVersion()  // the raw version is x.x.x
{
	std::string output;
	output = str( boost::format("%d.%d.%d") % (int)m_RadioProtocolVersion[0] % (int)m_RadioProtocolVersion[1] % (int)m_RadioProtocolVersion[2]);
	return output;
}
std::string LensRegisters::rawRadioProtocolVersion(std::string &output)  // the raw version is x.x.x
{
	output = str( boost::format("%d.%d.%d") % (int)m_RadioProtocolVersion[0] % (int)m_RadioProtocolVersion[1] % (int)m_RadioProtocolVersion[2]);
	return output;
}
std::string LensRegisters::rawRadioProtocolVersion_Upload(std::string &output)  // the upload version is x-x-x
{
	output = str( boost::format("%d-%d-%d") % (int)m_RadioProtocolVersion[0] % (int)m_RadioProtocolVersion[1] % (int)m_RadioProtocolVersion[2]);
	return output;
}


std::string LensRegisters::NetworkID(std::string &output)
{
	output = str( boost::format("Network ID:  " GREEN_ON "0x%02x%02x" RESET_COLOR) % (int)m_NetworkID[0] % (int)m_NetworkID[1]);
	return output;
}


std::string LensRegisters::EncryptionType(std::string &output)
{
	output = "Encryption: ";
	output += GREEN_ON;
	
	if (m_EncryptionType == 0)
		output += "0x00:No Encryption";
	else if (m_EncryptionType == 1)
		output += "0x01:AES-128 Encryption";
	else if (m_EncryptionType == 2)
		output += "0x02:Reserved - do not use!";
	else
		output += str(boost::format("0x%02x: unknown - THIS IS BAD!") % (int)m_EncryptionType);
	output += RESET_COLOR;
	return output;
}


std::string LensRegisters::EncryptionKey(std::string &output)
{
	output = "Encryption Key: ";
	bool enc = false;
	for (int i = 0; i < 16; i++)
		if (m_EncryptionKey[i])
		{
			enc = true;
			break;
		}
	
	if (enc)
	{
		char buf[24];
		memcpy(buf, m_EncryptionKey, 16);
		buf[16] = '\0';
		output += GREEN_ON;
		output += buf;	
	}
	else
	{
		output += YELLOW_ON;
		output = "Encryption Key is NULL.";
	}
	output += RESET_COLOR;
	return output;
}


std::string LensRegisters::PrimaryPublicChannel(std::string &output)
{
	output = str( boost::format("Primary Public Channel:  " GREEN_ON "%d" RESET_COLOR) % (int)m_PrimaryPublicChannel);
	return output;
}


std::string LensRegisters::SecondaryPublicChannel(std::string &output)
{
	output = str( boost::format("Secondary Public Channel:  " GREEN_ON "%d" RESET_COLOR) % (int)m_SecondaryPublicChannel);
	return output;
}


std::string LensRegisters::ActiveChannelMask(std::string &output)
{
	output = str( boost::format("ActiveChannelMask:  " GREEN_ON "0x%02x%02x" RESET_COLOR) % (int)m_ActiveChannelMask[0] % (int)m_ActiveChannelMask[1]);
	return output;
}
std::string LensRegisters::ActiveChannelMask()
{
	std::string output = str( boost::format("0x%02x%02x") % (int)m_ActiveChannelMask[0] % (int)m_ActiveChannelMask[1]);
	return output;
}


std::string LensRegisters::NetworkStatus(std::string &output)
{
	output = "Network Status:";
	output +=  GREEN_ON ;

	switch ( (int)m_NetworkStatus)
	{
		case 0:
			output += "00 Idle";
			break;
		case 1:
			output += "01 Configuring";
			break;
		case 2:
			output += "02 Connecting";
			break;
		case 3:
			output += "03 Connected as Follower";
			break;
		case 4:
			output += "04 Sleep";
			break;
		case 5:
			output += "05 Off Air";
			break;
		case 6:
			output += "06 Connected as Leader";
			break;
		case 7:
			output += "07 Test Mode";
			break;
		case 8:
			output += "08 Update Mode";
			break;
		case 9:
			output += "09 Listen All Mode";
			break;
		case 10:
			output += "10 Radio Scan State";
			break;
		default:
			output +=  YELLOW_ON ;
			output += "ERROR: Unknown Network Status!!!";
			break;
	}
	output += RESET_COLOR;
	return output;
}


std::string LensRegisters::MaxNumberOfHops(std::string &output)
{
	output = str( boost::format("Max Number of Hops: " GREEN_ON " %d" RESET_COLOR) % (int)m_MaxNumberOfHops);
	return output;
}


std::string LensRegisters::LeaderQualificationScore(std::string &output)
{
	output = str( boost::format("LeaderQualificationScore: " GREEN_ON " %d" RESET_COLOR) % (int)m_LeaderQualificationScore);
	return output;
}


std::string LensRegisters::NetworkInterval(std::string &output)
{
	output = str( boost::format("Network Interval:" GREEN_ON "  %d" RESET_COLOR) % (int)m_NetworkInterval);
	return output;
}


std::string LensRegisters::NumberOfPeers(std::string &output)
{
	output = str( boost::format("Number Of Peers: " GREEN_ON " %d" RESET_COLOR) % (int)m_NumberOfPeers);
	return output;
}


std::string LensRegisters::MaxNumberOfPeers(std::string &output)
{
	output = str( boost::format("Max Number Of Peers: " GREEN_ON " %d" RESET_COLOR) % (int)m_MaxNumberOfPeers);
	return output;
}


std::string LensRegisters::FeatureBits(std::string &output)
{
	output = str( boost::format("Feature Bits:" GREEN_ON "  0x%02x%02x" RESET_COLOR) % (int)m_FeatureBits[0] % (int)m_FeatureBits[1]);
	return output;
}

int LensRegisters::FeatureBits() const {return (((int)m_FeatureBits[0] << 8) + (int)m_FeatureBits[1]);}


std::string LensRegisters::ScriptCRC(std::string &output)
{
	output = str( boost::format("Script CRC: " GREEN_ON " 0x%02x%02x" RESET_COLOR) % (int)m_ScriptCRC[0] % (int)m_ScriptCRC[1]);
	return output;
}


std::string LensRegisters::TransmitPowerSetting(std::string &output)
{
	output = str( boost::format("Transmit Power Setting: " GREEN_ON " %d" RESET_COLOR) % (int)m_TransmitPowerSetting);
	return output;
}


std::string LensRegisters::GatewayChannelMask(std::string &output)
{
	output = str( boost::format("Gateway Channel Mask: " GREEN_ON " 0x%02x%02x" RESET_COLOR) % (int)m_GatewayChannelMask[0] % (int)m_GatewayChannelMask[1]);
	return output;
}


std::string LensRegisters::CurrentListeningChannel(std::string &output)
{
	output = str( boost::format("Transmit Power Setting: " GREEN_ON " %d" RESET_COLOR) % (int)m_TransmitPowerSetting);
	return output;
}


std::string LensRegisters::INetConnectionFlag(std::string &output)
{
	output = "INet Connection: ";
	output +=  GREEN_ON ;

	switch ( (int) m_INetConnectionFlag)
	{
		case 0:
		case 0xFF:
			output += "0x00: No iNet Connection";
			break;
		case 1:
			output += "0x01: etherNet";
			break;
		case 2:
			output += "0x02: Wifi";
			break;
		case 3:
			output += "0x03: Cellular";
			break;
		case 4:
			output += "0x04: Satellite";
			break;
		default:
			output +=  YELLOW_ON ;
			output += str(boost::format("ERROR: undefined iNet connection (0x%02x)") % (int)m_INetConnectionFlag);
			break;
	}
	output += RESET_COLOR;
	return output;
}



//-----------------------------------------------------------------------------------------------------------------
LensMAC LensRegisters::GetMAC()
{
	LensMAC mac;
	mac.MAC8(m_MAC);
	return mac;
}
