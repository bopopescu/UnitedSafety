# Mensajes en español para GNU sharutils.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Tomás Bautista <bautista@cma.ulpgc.es>, 1996.
# Santiago Vila <sanvila@unex.es>, 2006.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU sharutils 4.6.3-pre4\n"
"Report-Msgid-Bugs-To: bug-gnu-utils@gnu.org\n"
"POT-Creation-Date: 2006-06-03 12:18-0700\n"
"PO-Revision-Date: 2006-05-26 17:25+0200\n"
"Last-Translator: Santiago Vila <sanvila@unex.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: lib/error.c:131 lib/error.c:159
msgid "Unknown system error"
msgstr "Error del sistema desconocido"

#: lib/getopt.c:694
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: la opción `%s' es ambigua\n"

#: lib/getopt.c:719
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: la opción `--%s' no admite ningún argumento\n"

#: lib/getopt.c:724
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: la opción `%c%s' no admite ningún argumento\n"

#: lib/getopt.c:742 lib/getopt.c:915
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: la opción `%s' requiere un argumento\n"

#: lib/getopt.c:771
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: opción `--%s' no reconocida\n"

#: lib/getopt.c:775
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: opción `%c%s' no reconocida\n"

#: lib/getopt.c:801
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción ilegal -- %c\n"

#: lib/getopt.c:804
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: opción inválida -- %c\n"

#: lib/getopt.c:834 lib/getopt.c:964
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción requiere un argumento -- %c\n"

#: lib/getopt.c:881
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: la opción `-W %s' es ambigua\n"

#: lib/getopt.c:899
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: la opción `-W %s' no admite ningún argumento\n"

#: lib/xmalloc.c:66
msgid "memory exhausted"
msgstr "memoria agotada"

#: src/shar.c:606
msgid "Note: not verifying md5sums.  Consider installing GNU coreutils."
msgstr "Nota: no se verifican las sumas md5. Considere instalar GNU coreutils."

# Nota: Se supone que este mensaje continúa en el siguiente. De ahí el "e".
#
# FIXME: No se traducen palabras sueltas sino frases completas.
# Hablar con el autor.
#: src/shar.c:641
msgid "WARNING: not restoring timestamps.  Consider getting and"
msgstr ""
"ATENCIÓN: no se restablecerán las marcas de tiempo.\n"
"  Considere tomar e"

#: src/shar.c:643
msgid "installing GNU `touch'\\'', distributed in GNU coreutils..."
msgstr "instalar GNU `touch'\\'', distribuido con GNU coreutils..."

#: src/shar.c:650
msgid "lock directory '${lock_dir}' exists"
msgstr "el directorio de bloqueo '${lock_dir}' existe"

#: src/shar.c:655
msgid "failed to create lock directory"
msgstr "fallo al crear el directorio de bloqueo"

#: src/shar.c:659
#, c-format
msgid "x - created lock directory `'%s\\''."
msgstr "x - creado el directorio de bloqueo `'%s\\''."

#: src/shar.c:661
#, c-format
msgid "x - failed to create lock directory `'%s\\''."
msgstr "x - fallo al crear el directorio de bloqueo `'%s\\''."

#: src/shar.c:669
msgid "yes"
msgstr "sí"

#: src/shar.c:669
msgid "overwrite this file"
msgstr "sobrescribe este fichero"

#: src/shar.c:670
msgid "no"
msgstr "no"

#: src/shar.c:670
msgid "skip this file"
msgstr "salta este fichero"

#: src/shar.c:671
msgid "all"
msgstr "todos"

#: src/shar.c:671
msgid "overwrite all files"
msgstr "sobrescribe todos los ficheros"

#: src/shar.c:672
msgid "none"
msgstr "ninguno"

#: src/shar.c:672
msgid "overwrite no files"
msgstr "no sobrescribe ningún fichero"

#: src/shar.c:673
msgid "help"
msgstr "ayuda"

#: src/shar.c:673
msgid "explain choices"
msgstr "explica las opciones"

#: src/shar.c:674
msgid "quit"
msgstr "salir"

#: src/shar.c:674
msgid "exit immediately"
msgstr "sale inmediatamente"

#: src/shar.c:716
msgid "Too many directories for mkdir generation"
msgstr "Demasiados directorios para crear con `mkdir'"

#: src/shar.c:735
#, c-format
msgid "x - created directory `%s'\\''."
msgstr "x - creado el directorio `%s'\\''."

#: src/shar.c:737
#, c-format
msgid "x - failed to create directory `%s'\\''."
msgstr "x - fallo al crear el directorio `%s'\\''."

#: src/shar.c:804 src/shar.c:1055
#, c-format
msgid "Cannot access %s"
msgstr "No se puede acceder a %s"

#: src/shar.c:858
msgid "-C is being deprecated, use -Z instead"
msgstr "La opción -C está obsoleta, utilice -Z en su lugar"

#: src/shar.c:899 src/unshar.c:377
msgid "Cannot get current directory name"
msgstr "No se puede obtener el nombre del directorio actual"

#: src/shar.c:963
msgid ""
"Archives must be unpacked in sequence!\n"
"Please unpack part '`cat ${lock_dir}/seq`' next."
msgstr ""
"¡Los archivos deben desempaquetarse en orden!\n"
"Por favor desempaquete '`cat ${lock_dir}/seq`' a continuación."

#: src/shar.c:974 src/shar.c:1381
#, c-format
msgid "New file, remaining %s, "
msgstr "Nuevo fichero, faltan %s, "

#: src/shar.c:975 src/shar.c:1382
#, c-format
msgid "Limit still %s\n"
msgstr "El límite es aún %s\n"

#: src/shar.c:981 src/shar.c:1556 src/shar.c:1572
#, c-format
msgid "restore of %s failed"
msgstr "la restauración de %s falló"

#: src/shar.c:985
#, c-format
msgid "End of part %d, continue with part %d"
msgstr "Fin de la parte %d, continúa con la parte %d"

#: src/shar.c:999 src/shar.c:1475
#, c-format
msgid "Starting file %s\n"
msgstr "Fichero de comienzo %s\n"

#: src/shar.c:1050
#, c-format
msgid "%s: Not a regular file"
msgstr "%s: No es un fichero regular"

# Me resulta demasiado inconexo ... ¿y poner algo así como
# `quedan %ld bytes' aunque no sea tan fiel como debiera?
# ipg
# A mí no me disgusta. Pero pongo "faltan" en vez de "quedan". tb
#: src/shar.c:1065
#, c-format
msgid "In shar: remaining size %s\n"
msgstr "En `shar': faltan %s bytes\n"

#: src/shar.c:1084
msgid "empty"
msgstr "vacío"

#: src/shar.c:1085
msgid "(empty)"
msgstr "(vacío)"

#: src/shar.c:1109
#, c-format
msgid "Cannot open file %s"
msgstr "No se puede abrir el fichero %s"

# Para que esto "haga juego" con otra cosa que hay más abajo, quizá habría
# que poner "comprimido con `compress'", ¡qué horror! sv
# Sí, ya sé que es un poco raro, pero, ¿qué otra cosa se podría hacer? tb
# Nada, creo. O esto, o lo que había antes. sv
# Bueno, la verdad es que así se respeta fielmente el original, pues
# lo que se traducen no son palabras sino significados. sv
#: src/shar.c:1146
msgid "compressed"
msgstr "comprimido con `compress'"

#: src/shar.c:1147
msgid "gzipped"
msgstr "comprimido con `gzip'"

#: src/shar.c:1148
msgid "bzipped"
msgstr "comprimido con bzip"

#: src/shar.c:1149
msgid "binary"
msgstr "binario"

#: src/shar.c:1150
msgid "(compressed)"
msgstr "(comprimido)"

#: src/shar.c:1151
msgid "(gzipped)"
msgstr "(comprimido con `gzip')"

#: src/shar.c:1152
msgid "(bzipped)"
msgstr "(comprimido con bzip)"

#: src/shar.c:1153
msgid "(binary)"
msgstr "(binario)"

# Votaría por alguna descripción más amplia -- siempre doy la coña
# con esta frase:
# `No se pudo duplicar el proceso (falló la llamada a fork())'
# ipg
# O me equivoco, o hacer un fork no es duplicar un proceso, sino que crea
# un nuevo proceso:
#
# FORK(2V)                  SYSTEM CALLS                   FORK(2V)
#
# NAME
#      fork - create a new process
#
# Por lo tanto voy a escribir otra cosa. tb
#
# Te ha faltado citar esto de la misma página de manual:
#
# DESCRIPTION
#        fork  creates a child process that differs from the parent
#        process only in its PID and PPID, and  in  the  fact  that
#        resource  utilizations are set to 0.  File locks and pend­
#        ing signals are not inherited.
#
# fork() realmente lo único que hace es copiar las tablas de datos del
# núcleo del padre y los segmentos de datos del padre, por lo que lo
# único en lo que difieren justo después de la llamada a fork() es en el
# PID, en los locks y en las señales en espera de servicio. A eso se le
# llama duplicar un proceso. Que luego se use para crear un proceso
# nuevo con exec() es harina de otro costal, pero la única manera de
# crear más procesos en Unix es pasar por duplicar primero un proceso.
#
# También es verdad que al usuario qué gracia le hará la diferencia,
# pero no debemos confundir los huevos con las castañas, y al menos,
# intentar que la gente lo comprenda. ipg
#
#
# Esto lo discutí con Iñaky y Jim Meyering y al final les convencí :-)
# Lo cambio. sv
# Para la poteridá: Antes decía:
# "No se pudo crear un proceso nuevo: fallo en la llamada a `fork'"
# Pues lo dejamos cambiado. tb
#
# FIXME: Escribir al autor, de todas formas. sv+
#: src/shar.c:1166
msgid "Could not fork"
msgstr "Falló la llamada al sistema `fork'"

#: src/shar.c:1171 src/shar.c:1231
#, c-format
msgid "File %s (%s)"
msgstr "Fichero %s (%s)"

#: src/shar.c:1225
msgid "text"
msgstr "texto"

#: src/shar.c:1226
msgid "(text)"
msgstr "(texto)"

# He quitado una 'e' em+
#: src/shar.c:1249
#, c-format
msgid "overwriting %s"
msgstr "sobrescribiendo %s"

#: src/shar.c:1251
#, c-format
msgid "overwrite %s"
msgstr "sobrescribe %s"

# Estamos empleando extensivamente: 'pasando por alto' em+
# Bueno, eres tú quien lo está empleando extensivamente.
# Iñaky utiliza descartar, y yo depende del caso.
#
# Análisis semántico:
# Literalmente, skip es saltar, y quiere decir que no se considera.
# Pasar por alto, parece que sí se considera pero luego se hace la vista
# gorda, o algo así (como un "perdón").
# Tal vez por eso no me acabe de gustar "pasar por alto". sv+
#: src/shar.c:1255
#, c-format
msgid "SKIPPING %s"
msgstr "SALTANDO %s"

# interrumpida ?  sv
# Interrumpir y abortar, aunque son cosas similares,
# normalmente dan lugar a resultados distintos.
#: src/shar.c:1256
msgid "extraction aborted"
msgstr "extracción abortada"

#: src/shar.c:1260
#, c-format
msgid "SKIPPING %s (file already exists)"
msgstr "SALTANDO %s (el fichero ya existe)"

#: src/shar.c:1270
#, c-format
msgid "Saving %s (%s)"
msgstr "Guardando %s (%s)"

#: src/shar.c:1274
#, c-format
msgid "x - extracting %s %s"
msgstr "x - extrayendo< %s %s"

#: src/shar.c:1390
#, c-format
msgid "restore of %s failed\n"
msgstr "la restauración de %s falló\n"

#: src/shar.c:1399
#, c-format
msgid "End of part %ld, continue with part %ld"
msgstr "Fin de la parte %ld, continúa con la parte %ld"

# Nota: se supone que después de este mensaje aparece un numerito.
#: src/shar.c:1405
#, c-format
msgid "End of %s part %d"
msgstr "Fin de %s parte %d"

#: src/shar.c:1406
msgid "archive"
msgstr "archivo"

#: src/shar.c:1410
#, c-format
msgid "File %s is continued in part %d"
msgstr "El fichero %s continúa en la parte %d"

#: src/shar.c:1454
msgid "Please unpack part 1 first!"
msgstr "¡Por favor, desempaquete primero la parte 1!"

#: src/shar.c:1458
msgid "Please unpack part '${shar_sequence}' next!"
msgstr "¡Por favor, desempaquete la parte '${shar_sequence}' a continuación!"

# Idem em+
#: src/shar.c:1469
#, c-format
msgid "STILL SKIPPING %s"
msgstr "TODAVÍA SALTANDO %s"

#: src/shar.c:1477
#, c-format
msgid "continuing file %s"
msgstr "continuando con el fichero %s"

#: src/shar.c:1495
#, c-format
msgid "File %s is complete"
msgstr "El fichero %s se ha completado"

# Otra sugerencia: descodificando en lugar de decodificando. sv
# Y otra más: descodificando el archivo ... (añadir "el"). sv
# Ya... bueno. Por aquí solemos usar decodificar, en vez de descodificar,
# pero no sé cual es lo correcto. ¿Y qué tal descifrar? tb
#
# Me suena a criptografía (es decir, da a entender
# que está codificado de alguna manera extraña,
# cuando en realidad el "uuencode" es muy sencillo). sv
# ¿Entonces "descodificar"? Advierto que va a haber gente extrañada en
# este punto. Por ejemplo, yo. tb
#
# El Unix es bello .... :) ipg
#
# Una cosa: ¿decodificar o descodificar?
# (es que me suena mejor lo segundo) sv
#
# Para el Canal Plus ¿qué se usa? ¿un descodificador o un decodificador?
# Pregúntese a quien tenga uno, y entonces decidimos. tb
# :-) :-) :-) sv
#: src/shar.c:1502
#, c-format
msgid "uudecoding file %s"
msgstr "decodificando el fichero %s con `uudecode'"

# Nota: Añadir "con `uncompress'" está justificado por el hecho de que
# cuando se descomprime con gunzip se le llama "gunzipping".
#: src/shar.c:1512
#, c-format
msgid "uncompressing file %s"
msgstr "descomprimiendo el fichero %s con `uncompress'"

#: src/shar.c:1520
#, c-format
msgid "gunzipping file %s"
msgstr "descomprimiendo el fichero %s con `gunzip'"

#: src/shar.c:1528
#, c-format
msgid "bunzipping file %s"
msgstr "descomprimiendo el fichero %s con `bunzip'"

# Sugerencia: "suma de comprobación MD5" o "comprobación MD5". sv
# El "check" es el mismo "check" de "cheksum" (suma de comprobación), solo que
# MD5 no hace propiamente una suma sino un "revoltijo" con una
# función de `hash'. sv
# Los alemanes usan para esto `test.' Y a mí es una palabra que no me gusta,
# pero... tb
# Para MD5 he oído más los términos `huella digital MD5', `huella MD5'
# o `firma MD5'. ipg
# Pues si eso es lo que por ahí se oye, pues p'alante. tbd
# Si lo pones así, quizá quedaría mejor `Comprobación de la huella
# digital ...' y yo añadiría algo de `Es probable que el archivo esté
# jodido', pero más educadamente. ipg
# Hecho. tb
#
# Borro lo del fichero dañado. No es NADA fiel al original.
# Si el original hubiera querido decir algo acerca de un fichero dañado
# lo habría dicho. Además, puede que el fichero no esté dañado, sino
# que simplemente esté falsificado o sea otra versión.
#
# Propongo "Fallo en la suma MD5". Más fácil, más corto, más bonito...
# No importa que no sea exactamente una suma, puede considerarse una
# "suma generalizada". Además, el programa que genera eso se llama
# `md5sum' (es decir, parecido a "cheksum", y con la misma función aunque
# utilice un algoritmo distinto). sv
#
# No es la suma MD5 la que falla sino la comprobación, ¿no? tb
# Bueno, también puede decirse que es la suma la que falla, en tanto que no
# es la que debería ser. Déjalo como está, si te parece. sv
#: src/shar.c:1583
msgid "MD5 check failed"
msgstr "Fallo en la comprobación de la suma MD5"

#: src/shar.c:1639
#, c-format
msgid "'restoration warning:  size of %s is not %s'\n"
msgstr "'aviso de restauración: el tamaño de %s no es %s'\n"

#: src/shar.c:1691
msgid "allocating output file name"
msgstr "reserva de espacio para el nombre del fichero de salida"

#: src/shar.c:1697
#, c-format
msgid "Opening `%s'"
msgstr "Abriendo `%s'"

#: src/shar.c:1708
#, c-format
msgid "Closing `%s'"
msgstr "Cerrando `%s'"

#: src/shar.c:1720 src/unshar.c:313 src/uudecode.c:439 src/uuencode.c:204
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pruebe `%s --help' para más información.\n"

#: src/shar.c:1724 src/unshar.c:317
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Modo de empleo:  %s [OPCIÓN]... [FICHERO]...\n"

#: src/shar.c:1725
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"Los argumentos obligatorios para las opciones largas\n"
"también son obligatorios para las opciones cortas.\n"

#: src/shar.c:1728
msgid ""
"\n"
"Giving feedback:\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"  -q, --quiet, --silent   do not output verbose messages locally\n"
msgstr ""
"\n"
"Opciones de realimentación:\n"
"      --help            muestra esta ayuda y finaliza\n"
"      --version         informa de la versión y finaliza\n"
"  -q, --quiet, --silent  no muestra mensajes de progreso localmente\n"

#: src/shar.c:1736
msgid ""
"\n"
"Selecting files:\n"
"  -p, --intermix-type     allow -[BTzZ] in file lists to change mode\n"
"  -S, --stdin-file-list   read file list from standard input\n"
msgstr ""
"\n"
"Selección de ficheros:\n"
"  -p  --intermix-type      permite -[BTzZ] en listas de ficheros para "
"cambiar\n"
"                           el modo\n"
"  -S, --stdin-file-list    lee la lista de ficheros de la entrada estándar\n"

#: src/shar.c:1743
msgid ""
"\n"
"Selecting files:\n"
"  -p, --intermix-type     allow -[BTz] in file lists to change mode\n"
"  -S, --stdin-file-list   read file list from standard input\n"
msgstr ""
"\n"
"Selección de ficheros:\n"
"\n"
"  -p, --intermix-type     permite -[BTz] en listas de ficheros para cambiar "
"el\n"
"                          modo\n"
"  -S, --stdin-file-list   lee la lista de ficheros de la entrada estándar\n"

#: src/shar.c:1750
msgid ""
"\n"
"Splitting output:\n"
"  -o, --output-prefix=PREFIX    output to file PREFIX.01 through PREFIX.NN\n"
"  -l, --whole-size-limit=SIZE   split archive, not files, to SIZE kilobytes\n"
"  -L, --split-size-limit=SIZE   split archive, or files, to SIZE kilobytes\n"
msgstr ""
"\n"
"División del resultado:\n"
"  -o, --output-prefix=PREFIJO    coloca el resultado en PREFIJO.01 a PREFIJO."
"NN\n"
"  -l, --whole-size-limit=TAMAÑO  divide el archivo, no los ficheros, en "
"trozos\n"
"                                 de TAMAÑO kilobytes\n"
"  -L, --split-size-limit=TAMAÑO  divide el archivo, o los ficheros, en "
"trozos\n"
"                                 de TAMAÑO kilobytes\n"

# Otra cosa: El "controlling" y el "selecting" creo que no son gerundios.
# Diría que aquí lo que pega es:
# "Control de las cabeceras del archivo shar"
# "Selección de cómo se almacenan los archivos".
# ¿qué opinas? sv
#
# Nota: No hace falta poner sangría adicional cuando una opción te ocupe
# más de una línea. Solemos dejarlo al mismo nivel.
# (He cambiado tan sólo el "línea de corte", si estás de acuerdo, puedes
# hacerlo tú con los demás). sv
# ¿Coding -> cifrado? tb
# En -a ¿documentar? me suena un rato dao la vuerta :) ipg
# Vale. tb
#: src/shar.c:1757
msgid ""
"\n"
"Controlling the shar headers:\n"
"  -n, --archive-name=NAME   use NAME to document the archive\n"
"  -s, --submitter=ADDRESS   override the submitter name\n"
"  -a, --net-headers         output Submitted-by: & Archive-name: headers\n"
"  -c, --cut-mark            start the shar with a cut line\n"
"  -t, --translate           translate messages in the script\n"
"\n"
"Selecting how files are stocked:\n"
"  -M, --mixed-uuencode         dynamically decide uuencoding (default)\n"
"  -T, --text-files             treat all files as text\n"
"  -B, --uuencode               treat all files as binary, use uuencode\n"
"  -z, --gzip                   gzip and uuencode all files\n"
"  -g, --level-for-gzip=LEVEL   pass -LEVEL (default 9) to gzip\n"
"  -j, --bzip2                  bzip2 and uuencode all files\n"
msgstr ""
"\n"
"Control de las cabeceras de archivo `shar':\n"
"  -n, --archive-name=NOMBRE   usa NOMBRE para documentar el archivo\n"
"  -s, --submitter=DIRECCIÓN   ignora el nombre del remitente\n"
"  -a, --net-headers           documenta el archivo `shar' con cabeceras\n"
"                              de tipo `Submitted-by:' y `Archive-name:'\n"
"  -c, --cut-mark              comienza el archivo `shar' con una\n"
"                              línea de corte\n"
"  -t, --translate             traduce los mensajes del script\n"
"\n"
"Selección del modo de almacenamiento de los archivos:\n"
"  -M, --mixed-uuencode        decide automáticamente el cifrado con\n"
"                              `uuencode' (por defecto)\n"
"  -T, --text-files            trata todos los archivos como texto\n"
"  -B, --uuencode              trata todos los archivos como datos \n"
"                              binarios, utilizando `uuencode'\n"
"  -z, --gzip                  procesa todos los archivos con `gzip' y\n"
"                              `uuencode'\n"
"  -g, --level-for-gzip=NIVEL  pasa -NIVEL (por defecto 9) a `gzip'\n"
"  -j, --bzip2                 procesa todos los ficheros con bzip2\n"
"                              y uuencode\n"

#: src/shar.c:1775
msgid ""
"  -Z, --compress               compress and uuencode all files\n"
"  -b, --bits-per-code=BITS     pass -bBITS (default 12) to compress\n"
msgstr ""
"  -Z, --compress               comprime y codifica con uuencode todos los\n"
"                               ficheros\n"
"  -b, --bits-per-code=BITS     pasa -bBITS (por omisión 12) a compress\n"

# En -D, ¿qué tal `no comprueba la huella MD5 con `md5sum'' (donde
# digo `huella' pon lo que más te guste :)?
# En -V ¿`no exigente' -> `poco exigente'?
# En -Q ¿`actúa silenciosamente al ...'?
# Yo no traduciría `script' a `guión' ... me ha costado un rato darme
# cuenta de que querías decir (mente lúcida la mía que ha tardado en
# mirar la versión inglesa :). En todos sitios lo hemos dejado como
# script, pero entre comillas simples. Poca gente usa la palabra
# `guión' para referirse a un shell script.
# En -X `no para red' -> `no usar en Usenet o redes públicas'
# ipg
# Dejo algunas cosas como estaban (-Q) y otras las cambio. Lo de `guión',
# de acuerdo en dejarlo en `script' (me guiaba por algo que se discutió
# en la lista de spanglish). tb
#
# Lo de la "huella digital" para el "digest" me parece confuso y excesivo.
# Yo lo reservaría para la huella digital de PGP. sv
# Propongo algo más sencillo:
# "No utiliza la suma md5 para verificar.". sv
#
# Sospecho que en realidad utiliza algún algoritmo llamado md5sum ya
# definido en alguna librería para hacer esta comprobación, y lo que
# realmente viene a utilizar es el "digest" que obtiene de esta función. tb
#
# Bueno, ahora está mejor que antes, pero se puede confundir el
# algoritmo con el programa que lo implementa con el resultado del algoritmo.
# (Siendo efectivamente esto último a lo que se refiere realmente).
# Pero mejor lo dejamos así, no vaya a ser que al intentar traducir
# `digest' quede peor... sv
#: src/shar.c:1780
msgid ""
"\n"
"Protecting against transmission:\n"
"  -w, --no-character-count      do not use `wc -c' to check size\n"
"  -D, --no-md5-digest           do not use `md5sum' digest to verify\n"
"  -F, --force-prefix            force the prefix character on every line\n"
"  -d, --here-delimiter=STRING   use STRING to delimit the files in the shar\n"
"\n"
"Producing different kinds of shars:\n"
"  -V, --vanilla-operation   produce very simple and undemanding shars\n"
"  -P, --no-piping           exclusively use temporary files at unshar time\n"
"  -x, --no-check-existing   blindly overwrite existing files\n"
"  -X, --query-user          ask user before overwriting files (not for Net)\n"
"  -m, --no-timestamp        do not restore file modification dates & times\n"
"  -Q, --quiet-unshar        avoid verbose messages at unshar time\n"
"  -f, --basename            restore in one directory, despite hierarchy\n"
"      --no-i18n             do not produce internationalized shell script\n"
msgstr ""
"\n"
"Protección contra transmisión:\n"
"  -w, --no-character-count     no usa `wc -c' para verificar el tamaño\n"
"  -D, --no-md5-digest          no utiliza `md5sum' para verificar\n"
"  -F, --force-prefix           fuerza el carácter de prefijo en todas\n"
"                               las líneas\n"
"  -d, --here-delimiter=CADENA  usa CADENA para delimitar los ficheros en\n"
"                               el archivo `shar'\n"
"\n"
"Producción de distintas clases de archivos `shar':\n"
"  -V, --vanilla-operation   produce archivos `shar' muy sencillos y\n"
"                            poco exigentes\n"
"  -P, --no-piping           usa exclusivamente archivos temporales al\n"
"                            deshacer el archivo `shar'\n"
"  -x, --no-check-existing   escribe sin confirmar sobre archivos\n"
"                            existentes\n"
"  -X, --query-user          pregunta al usuario antes de escribir sobre\n"
"                            archivos (no para red)\n"
"  -m, --no-timestamp        no restaura las fechas y horas de modificación\n"
"                            del fichero\n"
"  -Q, --quiet-unshar        impide producir mensajes al deshacer\n"
"                            el archivo `shar'\n"
"  -f, --basename            restaura en un directorio, sin tener en cuenta\n"
"                            la jerarquía\n"
"      --no-i18n             no produce `script' de shell internacionalizado\n"

#: src/shar.c:1798
msgid ""
"\n"
"Option -o is required with -l or -L, option -n is required with -a.\n"
msgstr ""
"\n"
"La opción -o es necesaria con -l o -L, la opción -n es necesaria con -a.\n"

#: src/shar.c:1802
msgid "Option -g implies -z, option -b implies -Z.\n"
msgstr "La opción -g implica -z, la opción -b implica -Z.\n"

#: src/shar.c:1805
msgid "Option -g implies -z.\n"
msgstr "La opción -g implica -z.\n"

# Nota: Lo del último traductor es provisional hasta que piense algo mejor.
#. TRANSLATORS: add the contact address for your translation team!
#: src/shar.c:1809 src/unshar.c:332 src/uudecode.c:450 src/uuencode.c:214
#, c-format
msgid "Report bugs to <%s>.\n"
msgstr ""
"Comunicar bichos a <%s>.\n"
"Comunicar errores de traducción al último traductor:\n"
" msgunfmt /usr/share/locale/es/LC_MESSAGES/sharutils.mo | grep Last-"
"Translator\n"

#: src/shar.c:1867
#, c-format
msgid "invalid file size limit `%s'"
msgstr "límite de tamaño de fichero inválido `%s'"

#: src/shar.c:1903
#, c-format
msgid "invalid format (count field too wide): '%s'\n"
msgstr "formato inválido (campo \"count\" demasiado ancho): '%s'\n"

#: src/shar.c:1964
msgid "DEBUG was not selected at compile time"
msgstr "No se seleccionó DEBUG en la compilación"

# ¿Límite fijo o infranqueable? ipg
# Buena pregunta. Quién podrá resolverla? tb
# El resolvedor que la resuelva buen resolvedor será ...
# Me sace que aquí se refiere al límite duro, al que es `no más Santo
# Tomás'. Según recuerdo, el soft es el que se te deja pasar (en las
# cuotas, por ejemplo) por un periodo de gracia, pasado el cual, te
# abren el culo. El hard es el que no puedes pasar ni hinchao de
# coca. Yo creo que traduciría `Soft limit' como `Límite de aviso' y
# `Hard limit' como 'Límite inexcedible'. ipg
# "límite por hardware" me parece perfecto. sv
#: src/shar.c:1984
#, c-format
msgid "Hard limit %s\n"
msgstr "Límite por hardware %s\n"

#: src/shar.c:2026
msgid "This system doesn't support -Z ('compress'), use -z instead"
msgstr "Este sistema no admite -Z ('compress'), utilice -z en su lugar"

# ¿Límite de aviso? ipg
# Otra buena pregunta. tb
# Me remito a la anterior respuesta :). ipg
#: src/shar.c:2059
#, c-format
msgid "Soft limit %s\n"
msgstr "Límite por software %s\n"

#: src/shar.c:2074
#, c-format
msgid "illegal output prefix\n"
msgstr "prefijo de salida ilegal\n"

#: src/shar.c:2121 src/unshar.c:415 src/uudecode.c:488 src/uuencode.c:254
#, c-format, no-wrap
msgid ""
"Copyright (C) %s Free Software Foundation, Inc.\n"
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
msgstr ""
"Copyright (C) %s Free Software Foundation, Inc.\n"
"Esto es software libre; vea el código fuente para las condiciones de copia.\n"
"No hay NINGUNA garantía; ni siquiera de COMERCIABILIDAD o IDONEIDAD PARA UN\n"
"FIN DETERMINADO.\n"

# ver arriba del todo.
# Lo cambio, con permiso. sv
#: src/shar.c:2168
msgid "WARNING: No user interaction in vanilla mode"
msgstr "ATENCIÓN: No se permite la interacción del usuario en modo `vanilla'"

# ¿overridden es ignoradas? tal y como ha quedado no me parece fiel.
# tal vez añadiendo las opciones por defecto o algo así. ¿qué te
# parece? sv Overriden, desde mi punto de vista, significa que a las
# opciones que se introdujeron "no se les hace caso" override". O sea,
# que... cómo lo ponemos? tb
# ¿sustituídas? sv
# Los alemanes usan algo como "sobreescritas". No es por nada, pero...
# no se sustituyen estas opciones: se descartan? Se pasan por alto?
#
# Se ignoran? tb
#
# Esto es delicado. Ignorar es "no saber", pero por culpa de la
# palabra inglesa "ignore", la gente está empezando a usar "ignorar" como
# sinónimo de lo que realmente significa "ignore": no hacer caso.
# (mantengo una lucha sin cuartel contra esta palabra con ese significado).
# ^^^ Ya será menos, Santiago ;) ipg (¡e broma :D!)
# En estos casos se pueden usar "descartar", "no tener efecto"
# "pasar por alto", y cosas así.
# ¿Te gusta alguna? sv
# Pues sí... `descartadas' no me disgusta. No sé si preferiría `desechadas'
# aunque a lo mejor alguien pondrá pegas. tb
#
# Sí, yo... me suena a desechos (desperdicios). No sé. sv
# Ya, ya lo sabía... Cambio a "descartadas" a ver. tb
#: src/shar.c:2180
msgid "WARNING: Non-text storage options overridden"
msgstr "ATENCIÓN: Descartadas las opciones de almacenamiento para no-texto"

# Sugerencia: "No hay ningún archivo de entrada". sv
# Apoyo la moción. ipg
# De acuerdo, en parte. tb
# Esta frase ya ha salido en otra ocasión.
# Si ponemos "No se han indicado archivos de entrada"
# el plural parece indicar que hay que dar varios archivos de entrada.
# Lo cambio, a ver si te gusta. sv
#: src/shar.c:2236
msgid "No input files"
msgstr "No se ha indicado ningún fichero de entrada"

#: src/shar.c:2242
msgid "Cannot use -a option without -n"
msgstr "No se puede usar la opción -a sin -n"

#: src/shar.c:2248
msgid "Cannot use -l or -L option without -o"
msgstr "No se puede usar la opción -l ó -L sin -o"

#: src/shar.c:2260
msgid "PLEASE avoid -X shars on Usenet or public networks"
msgstr ""
"POR FAVOR evite archivos creados con `shar -X' en Usenet o redes públicas"

#: src/shar.c:2301
msgid "You have unpacked the last part"
msgstr "Ha desempaquetado la última parte"

#: src/shar.c:2303
#, c-format
msgid "Created %d files\n"
msgstr "Creados %d ficheros\n"

#: src/shar.c:2308
#, c-format
msgid "x - removed lock directory `'%s\\''."
msgstr "x - borrado el directorio de bloqueo `'%s\\''."

#: src/shar.c:2310
#, c-format
msgid "x - failed to remove lock directory `'%s\\''."
msgstr "x - fallo al borrar el directorio de bloqueo `'%s\\''."

#: src/unshar.c:169
#, c-format
msgid "Found no shell commands in %s"
msgstr "No se encontraron instrucciones de shell en %s"

#: src/unshar.c:185
#, c-format
msgid "%s looks like raw C code, not a shell archive"
msgstr "%s parece código C, no un archivo de shell"

#: src/unshar.c:221
#, c-format
msgid "Found no shell commands after `cut' in %s"
msgstr "No se encontraron instrucciones de shell después de `cut' en %s"

#: src/unshar.c:242
#, c-format
msgid "%s is probably not a shell archive"
msgstr "Probablemente %s no es un archivo de shell"

#: src/unshar.c:243
#, c-format
msgid "The `cut' line was followed by: %s"
msgstr "La línea `cut' estaba seguida por: %s"

#: src/unshar.c:269
msgid "Starting `sh' process"
msgstr "Iniciando el proceso `sh'"

# guión -> `script'
# ¿concatenados o concadenados?
# ipg
# Por aquí usamos "concatenar", pero veo que es "concadenar". Cambiado. tb
# No lo lleves tan a misa :) que yo no estaba muy seguro. Ahora he
# mirado el diccionario, y resulta que ambas son válidas. Elige tú; a mí
# personalmente (y no sé por qué) me gusta más `concatenar'). ipg
# Y a mí también: es lo que la gente usa por aquí... tb
#: src/unshar.c:318
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
"\n"
"  -d, --directory=DIRECTORY   change to DIRECTORY before unpacking\n"
"  -c, --overwrite             pass -c to shar script for overwriting files\n"
"  -e, --exit-0                same as `--split-at=\"exit 0\"'\n"
"  -E, --split-at=STRING       split concatenated shars after STRING\n"
"  -f, --force                 same as `-c'\n"
"      --help                  display this help and exit\n"
"      --version               output version information and exit\n"
"\n"
"If no FILE, standard input is read.\n"
msgstr ""
"Los argumentos obligatorios para las opciones largas\n"
"también son obligatorios para las opciones cortas.\n"
"\n"
"  -d, --directory=DIRECTORIO  cambia a DIRECTORIO antes de desempaquetar\n"
"  -c, --overwrite             pasa -c al `script' shar para sobreescribir\n"
"                              ficheros\n"
"  -e, --exit-0                igual que `--split-at=\"exit 0\"'\n"
"  -E, --split-at=CADENA       divide los archivos `shar' concatenados\n"
"                              tras encontrar CADENA\n"
"  -f, --force                 igual que `-c'\n"
"      --help                  muestra esta ayuda y finaliza\n"
"      --version               informa de la versión y finaliza\n"
"\n"
"Si no se indica FICHERO, entonces se lee la entrada estándar.\n"

#: src/unshar.c:395
#, c-format
msgid "Cannot chdir to `%s'"
msgstr "No se puede cambiar al directorio `%s'"

#: src/unshar.c:446 src/unshar.c:508
msgid "allocate file name buffer"
msgstr "reserva de espacio para el nombre del fichero"

#: src/unshar.c:467
msgid "standard input"
msgstr "entrada estándar"

#: src/unshar.c:529
msgid "allocate file buffer"
msgstr "reserva de espacio para el fichero"

#: src/uudecode.c:123 src/uudecode.c:427
#, c-format
msgid "%s: Write error"
msgstr "%s: Error de escritura"

#: src/uudecode.c:141 src/uudecode.c:229
#, c-format
msgid "%s: Short file"
msgstr "%s: Fichero cortado"

#: src/uudecode.c:177
#, c-format
msgid "%s: No `end' line"
msgstr "%s: No hay línea `end'"

#: src/uudecode.c:238
#, c-format
msgid "%s: data following `=' padding character"
msgstr "%s: datos posteriores al carácter de relleno `='"

# Preferiría "no válida". Pero vamos a dejarlo a ver qué opinan otros,
# ¿vale? tb
# Por mí, vale así, a ver qué dice Enrique cuando lo vea. sv
# (Pero que conste que yo te apoyo con lo de "ilegal") sv
# Yo opino que `no válida'. ipg
# Pues si ya somos tres, no creo que vaya a esperar mucho a poner `no válida'.
# A la próxima... tbd
# No, yo decía que por mí vale "ilegal". Prefiero ilegal. sv
#: src/uudecode.c:262 src/uudecode.c:270 src/uudecode.c:284
#, c-format
msgid "%s: illegal line"
msgstr "%s: línea ilegal"

# Aquí tal vez se podría añadir "ninguna".
# "No hay ninguna línea `begin'". sv+
#: src/uudecode.c:324
#, c-format
msgid "%s: No `begin' line"
msgstr "%s: No hay línea `begin'"

# Ver el código fuente. Igual no habría que traducir ~user. sv
# No sé qué es lo que convendría... tb
# Yo creo que no es ilegal. Eso está especificando que la terminología
# de ~<usuario> no está aceptada ... a mi me parece que vale. ipg
# A ver: tenía puesto "~usuario inexistente". Qu'e es lo que viene mejor
# entre esta opción, "~usuario no válido" y "~usuario ilegal"? tb
# ¡¡Joder!! Pues ahora ni me aclaro ni ná de ná, ¿sabes seguro si el
# mensaje se usa para decir que no se acepta la terminología ~<usuario>
# o porque el <usuario> dado no existe? Si es lo primero, que lo dudo,
# me inclino por ilegal, y si es la segunda, por poner `El usuario
# especificado no existe'. ipg
#: src/uudecode.c:356
#, c-format
msgid "%s: Illegal ~user"
msgstr "%s: ~usuario ilegal"

#: src/uudecode.c:363
#, c-format
msgid "%s: No user `%s'"
msgstr "%s: No hay ningún usuario `%s'"

#: src/uudecode.c:387
#, c-format
msgid "cannot access %s"
msgstr "no se puede acceder a %s"

#: src/uudecode.c:392
#, c-format
msgid "denied writing FIFO (%s)"
msgstr "denegada la escritura al FIFO (%s)"

#: src/uudecode.c:397
#, c-format
msgid "not following symlink (%s)"
msgstr "no se sigue al enlace (%s)"

#: src/uudecode.c:405
#, c-format
msgid "freopen of %s"
msgstr "Efectuando freopen sobre %s"

#: src/uudecode.c:411
#, c-format
msgid "chmod of %s"
msgstr "Efectuando chmod sobre %s"

#: src/uudecode.c:443
#, c-format
msgid "Usage: %s [FILE]...\n"
msgstr "Modo de empleo: %s [FICHERO]...\n"

#: src/uudecode.c:444
msgid ""
"Mandatory arguments to long options are mandatory to short options too.\n"
"  -o, --output-file=FILE   direct output to FILE\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
msgstr ""
"Los argumentos obligatorios para las opciones largas son también "
"obligatorios\n"
"para las opciones cortas.\n"
"\n"
"  -o, --output-file=FICHERO  dirige la salida hacia FICHERO\n"
"      --help                 muestra esta ayuda y finaliza\n"
"      --version              informa de la versión y finaliza\n"

#: src/uuencode.c:135 src/uuencode.c:303 src/uuencode.c:310
msgid "Write error"
msgstr "Error de escritura"

#: src/uuencode.c:157 src/uuencode.c:188 src/uuencode.c:190
msgid "Read error"
msgstr "Error de lectura"

#: src/uuencode.c:208
#, c-format
msgid "Usage: %s [INFILE] REMOTEFILE\n"
msgstr "Modo de empleo: %s [FICHERO-DE-ENTRADA] FICHERO-REMOTO\n"

#: src/uuencode.c:209
msgid ""
"\n"
"  -m, --base64    use base64 encoding as of RFC1521\n"
"      --help      display this help and exit\n"
"      --version   output version information and exit\n"
msgstr ""
"\n"
"  -m, --base64    utiliza base64 como se indica en RFC1521\n"
"      --help      muestra esta ayuda y finaliza\n"
"      --version   informa de la versión y finaliza\n"

#: src/uuencode.c:275
#, c-format
msgid "fopen-ing %s"
msgstr "Efectuando fopen sobre %s"

#: src/uuencode.c:277
#, c-format
msgid "fstat-ing %s"
msgstr "Efectuando fstat sobre %s"

# Ídem ... ipg
# Ídem. tb
#~ msgid "lock directory"
#~ msgstr "directorio de bloqueo"

#~ msgid "created"
#~ msgstr "creado"

#~ msgid "failed to create"
#~ msgstr "fallo al crear"

#~ msgid "Must unpack archives in sequence!"
#~ msgstr "¡Debe desempaquetar los archivos en orden!"

# Me da en la nariz que este fallido se usa para conectar con
# la frase anterior en algo como `restauración de <archivo> fallida',
# por lo que quizá debería ser `fallida'. Creo que tendrías que
# echar un ojo a las fuentes. ipg
# Efectivamente. Aparte que ambos mensajes están siempre en la misma
# línea. Lo cambio. tb
#~ msgid "failed"
#~ msgstr "fallida"

# Habrá que vigilar a ver si dan la oportunidad de traducir también
# "n" "y" "a" y "q" pues si no, habrá que poner en su lugar algo como
# n (no) y (si). etc. sv
# En alemán está puesto como está puesto aquí.
# No se pueden traducir las opciones. tb
# Pero afortunadamente están empezando a traducir algunas cosas
# parecidas a esta. Mañana o pasado saldrá una versión de prueba de
# fileutils que cuando haces rm -i y te pregunta ¿borrar `lo.que.sea'?
# ya puedes contestar "s" o "n".
# Supongo que habrá que luchar por ello la próxima vez que haya oportunidad.
# (Estar al loro en la lista de "pretest", si existe). sv
# Vale. Hasta que eso sea así, lo mantenemos de este modo
# *provisionalmente*. tb
#~ msgid "[no, yes, all, quit] (no)?"
#~ msgstr "¿[no (n), sí (y), todo (a), salir (q)] (no)?"

#~ msgid "End of"
#~ msgstr "Fin de"

#~ msgid "part"
#~ msgstr "parte"

#~ msgid "File"
#~ msgstr "Archivo"

#~ msgid "original size"
#~ msgstr "tamaño original"

#~ msgid "current size"
#~ msgstr "tamaño actual"

# Sugerencias: acaba -> finaliza. sv
# Aquí se usa más "termina" o "sale". ¿Qué usa la gente por ahí? tb
# finaliza queda como más elegante.
# Solemos poner "termina" para los procesos, eso sí, pero no para
# el programa. sv
#
# Creo que "en la misma línea" están los otros, la terminación "ing" no
# siempre indica gerundio. La verdad es que es difícil... sv
#
# Ese `Dando información' me suena raro, ¿qué tal `para obtener
# información del programa'? No es tan literal, pero si más castellano
# inteligible y agradable de leer, a la vez que dice lo que el guiri.
# En --version hemos puesto en todos lados lo siguiente:
# "--version  informa de la version y finaliza\n", te lo cambio
# En -q ... `actúa silenciosamente' ¿qué tal? (a veces ceñirse al
# original da unas frases que me suenan harto extrañas).
# ¿"Troceando la salida:\n" -> "Para particionar la salida:\n"?
# ¿No te suena `troceando' a la matanza del gorrino? :)
# En -o, te sugiero `manda la salida a los archivos PREFIJO.01,
# PREFIJO.02... PREFIJO.NN'; es más largo, pero a mi juicio (al menos ;)
# se entiende mejor.
# En -l y -L se confunde el `archive' guiri con el `archivo' castellano
# que se refiere a `file'. Quizá deberías decir (además de en mi
# opinión trocear->partir) `Parte el archivo shar (no los archivos) en
# partes de TAMAÑO kilobytes', y similarmente con -L.
# Otra cosa: en las líneas de comando, en lugar del infinitivo para
# el verbo, usa la tercera persona del singular. Lo hacemos así en todos
# sitios
# ipg
# "Dando información" -> "Informacion sobre las opciones"
# "no muestra mensajes del proceso localmente" -> "no muestra mensajes sobre
# el procesamiento" -- (¿"actua en silencio"?)
# "Troceando la salida" -> "División de la salida"
# tb
#
# Y además no es porque "lo hagamos así", ¡es que es eso lo que significa!
# Se llama "gerundio sustantivado", y aparece mencionado en la lista de
# pifias de Ángel Álvarez. sv
#~ msgid ""
#~ "\n"
#~ "Giving feedback:\n"
#~ "      --help              display this help and exit\n"
#~ "      --version           output version information and exit\n"
#~ "  -q, --quiet, --silent   do not output verbose messages locally\n"
#~ "\n"
#~ "Selecting files:\n"
#~ "  -p, --intermix-type     allow -[BTzZ] in file lists to change mode\n"
#~ "  -S, --stdin-file-list   read file list from standard input\n"
#~ "\n"
#~ "Splitting output:\n"
#~ "  -o, --output-prefix=PREFIX    output to file PREFIX.01 through PREFIX."
#~ "NN\n"
#~ "  -l, --whole-size-limit=SIZE   split archive, not files, to SIZE "
#~ "kilobytes\n"
#~ "  -L, --split-size-limit=SIZE   split archive, or files, to SIZE "
#~ "kilobytes\n"
#~ msgstr ""
#~ "\n"
#~ "Información sobre las opciones:\n"
#~ "      --help              muestra esta ayuda y finaliza\n"
#~ "      --version           informa de la versión y finaliza\n"
#~ "  -q, --quiet, --silent   no muestra mensajes sobre el procesamiento\n"
#~ "\n"
#~ "Selección de archivos:\n"
#~ "  -p, --intermix-type     permite -[BTzZ] en las listas de archivos\n"
#~ "                          para cambiar de modo\n"
#~ "  -S, --stdin-file-list   lee la lista de archivos de la entrada "
#~ "estándar\n"
#~ "\n"
#~ "División de la salida:\n"
#~ "  -o, --output-prefix=PREFIJO   deja el resultado en los archivos\n"
#~ "                                del PREFIJO.01 hasta PREFIJO.NN\n"
#~ "  -l, --whole-size-limit=TAMAÑO divide el archivo `shar', no los "
#~ "archivos,\n"
#~ "                                a TAMAÑO kilobytes\n"
#~ "  -L, --split-size-limit=TAMAÑO divide el archivo `shar' o archivos\n"
#~ "                                a TAMAÑO kilobytes\n"

#~ msgid "Report bugs to <bug-gnu-utils@prep.ai.mit.edu>.\n"
#~ msgstr "Comunicar `bugs' a <bug-gnu-utils@prep.ai.mit.edu>.\n"

#~ msgid "removed"
#~ msgstr "borrado"

#~ msgid "failed to remove"
#~ msgstr "fallo al borrar"
